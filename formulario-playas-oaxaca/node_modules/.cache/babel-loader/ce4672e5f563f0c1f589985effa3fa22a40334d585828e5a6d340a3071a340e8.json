{"ast":null,"code":"'use strict';\n\nconst path = require('path');\nconst fs = require('graceful-fs');\nconst pathExists = require('../path-exists').pathExists;\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths(srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, err => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink');\n        return callback(err);\n      }\n      return callback(null, {\n        toCwd: srcpath,\n        toDst: srcpath\n      });\n    });\n  } else {\n    const dstdir = path.dirname(dstpath);\n    const relativeToDst = path.join(dstdir, srcpath);\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err);\n      if (exists) {\n        return callback(null, {\n          toCwd: relativeToDst,\n          toDst: srcpath\n        });\n      } else {\n        return fs.lstat(srcpath, err => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink');\n            return callback(err);\n          }\n          return callback(null, {\n            toCwd: srcpath,\n            toDst: path.relative(dstdir, srcpath)\n          });\n        });\n      }\n    });\n  }\n}\nfunction symlinkPathsSync(srcpath, dstpath) {\n  let exists;\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath);\n    if (!exists) throw new Error('absolute srcpath does not exist');\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    };\n  } else {\n    const dstdir = path.dirname(dstpath);\n    const relativeToDst = path.join(dstdir, srcpath);\n    exists = fs.existsSync(relativeToDst);\n    if (exists) {\n      return {\n        toCwd: relativeToDst,\n        toDst: srcpath\n      };\n    } else {\n      exists = fs.existsSync(srcpath);\n      if (!exists) throw new Error('relative srcpath does not exist');\n      return {\n        toCwd: srcpath,\n        toDst: path.relative(dstdir, srcpath)\n      };\n    }\n  }\n}\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n};","map":{"version":3,"names":["path","require","fs","pathExists","symlinkPaths","srcpath","dstpath","callback","isAbsolute","lstat","err","message","replace","toCwd","toDst","dstdir","dirname","relativeToDst","join","exists","relative","symlinkPathsSync","existsSync","Error","module","exports"],"sources":["/home/paulo/.Code/web/login-estructura/login-no-funcional/node_modules/fs-extra/lib/ensure/symlink-paths.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        toCwd: srcpath,\n        toDst: srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          toCwd: relativeToDst,\n          toDst: srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            toCwd: srcpath,\n            toDst: path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        toCwd: relativeToDst,\n        toDst: srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        toCwd: srcpath,\n        toDst: path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}