{"ast":null,"code":"'use strict';\n\nconst fs = require('../fs');\nconst path = require('path');\nconst {\n  mkdirs\n} = require('../mkdirs');\nconst {\n  pathExists\n} = require('../path-exists');\nconst {\n  utimesMillis\n} = require('../util/utimes');\nconst stat = require('../util/stat');\nasync function copy(src, dest, opts = {}) {\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' + '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0001');\n  }\n  const {\n    srcStat,\n    destStat\n  } = await stat.checkPaths(src, dest, 'copy', opts);\n  await stat.checkParentPaths(src, srcStat, dest, 'copy');\n  const include = await runFilter(src, dest, opts);\n  if (!include) return;\n\n  // check if the parent of dest exists, and create it if it doesn't exist\n  const destParent = path.dirname(dest);\n  const dirExists = await pathExists(destParent);\n  if (!dirExists) {\n    await mkdirs(destParent);\n  }\n  await getStatsAndPerformCopy(destStat, src, dest, opts);\n}\nasync function runFilter(src, dest, opts) {\n  if (!opts.filter) return true;\n  return opts.filter(src, dest);\n}\nasync function getStatsAndPerformCopy(destStat, src, dest, opts) {\n  const statFn = opts.dereference ? fs.stat : fs.lstat;\n  const srcStat = await statFn(src);\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);\n  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);\n  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);\n  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);\n  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);\n  throw new Error(`Unknown file: ${src}`);\n}\nasync function onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts);\n  if (opts.overwrite) {\n    await fs.unlink(dest);\n    return copyFile(srcStat, src, dest, opts);\n  }\n  if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`);\n  }\n}\nasync function copyFile(srcStat, src, dest, opts) {\n  await fs.copyFile(src, dest);\n  if (opts.preserveTimestamps) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcStat.mode)) {\n      await makeFileWritable(dest, srcStat.mode);\n    }\n\n    // Set timestamps and mode correspondingly\n\n    // Note that The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n    const updatedSrcStat = await fs.stat(src);\n    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n  }\n  return fs.chmod(dest, srcStat.mode);\n}\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\nfunction makeFileWritable(dest, srcMode) {\n  return fs.chmod(dest, srcMode | 0o200);\n}\nasync function onDir(srcStat, destStat, src, dest, opts) {\n  // the dest directory might not exist, create it\n  if (!destStat) {\n    await fs.mkdir(dest);\n  }\n  const items = await fs.readdir(src);\n\n  // loop through the files in the current directory to copy everything\n  await Promise.all(items.map(async item => {\n    const srcItem = path.join(src, item);\n    const destItem = path.join(dest, item);\n\n    // skip the item if it is matches by the filter function\n    const include = await runFilter(srcItem, destItem, opts);\n    if (!include) return;\n    const {\n      destStat\n    } = await stat.checkPaths(srcItem, destItem, 'copy', opts);\n\n    // If the item is a copyable file, `getStatsAndPerformCopy` will copy it\n    // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively\n    return getStatsAndPerformCopy(destStat, srcItem, destItem, opts);\n  }));\n  if (!destStat) {\n    await fs.chmod(dest, srcStat.mode);\n  }\n}\nasync function onLink(destStat, src, dest, opts) {\n  let resolvedSrc = await fs.readlink(src);\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n  }\n  if (!destStat) {\n    return fs.symlink(resolvedSrc, dest);\n  }\n  let resolvedDest = null;\n  try {\n    resolvedDest = await fs.readlink(dest);\n  } catch (e) {\n    // dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest);\n    throw e;\n  }\n  if (opts.dereference) {\n    resolvedDest = path.resolve(process.cwd(), resolvedDest);\n  }\n  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);\n  }\n\n  // do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);\n  }\n\n  // copy the link\n  await fs.unlink(dest);\n  return fs.symlink(resolvedSrc, dest);\n}\nmodule.exports = copy;","map":{"version":3,"names":["fs","require","path","mkdirs","pathExists","utimesMillis","stat","copy","src","dest","opts","filter","clobber","overwrite","preserveTimestamps","process","arch","emitWarning","srcStat","destStat","checkPaths","checkParentPaths","include","runFilter","destParent","dirname","dirExists","getStatsAndPerformCopy","statFn","dereference","lstat","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","isSocket","Error","isFIFO","copyFile","unlink","errorOnExist","fileIsNotWritable","mode","makeFileWritable","updatedSrcStat","atime","mtime","chmod","srcMode","mkdir","items","readdir","Promise","all","map","item","srcItem","join","destItem","resolvedSrc","readlink","resolve","cwd","symlink","resolvedDest","e","code","isSrcSubdir","module","exports"],"sources":["/home/paulo/.Code/web/login-estructura/login-no-funcional/node_modules/fs-extra/lib/copy/copy.js"],"sourcesContent":["'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst { mkdirs } = require('../mkdirs')\nconst { pathExists } = require('../path-exists')\nconst { utimesMillis } = require('../util/utimes')\nconst stat = require('../util/stat')\n\nasync function copy (src, dest, opts = {}) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0001'\n    )\n  }\n\n  const { srcStat, destStat } = await stat.checkPaths(src, dest, 'copy', opts)\n\n  await stat.checkParentPaths(src, srcStat, dest, 'copy')\n\n  const include = await runFilter(src, dest, opts)\n\n  if (!include) return\n\n  // check if the parent of dest exists, and create it if it doesn't exist\n  const destParent = path.dirname(dest)\n  const dirExists = await pathExists(destParent)\n  if (!dirExists) {\n    await mkdirs(destParent)\n  }\n\n  await getStatsAndPerformCopy(destStat, src, dest, opts)\n}\n\nasync function runFilter (src, dest, opts) {\n  if (!opts.filter) return true\n  return opts.filter(src, dest)\n}\n\nasync function getStatsAndPerformCopy (destStat, src, dest, opts) {\n  const statFn = opts.dereference ? fs.stat : fs.lstat\n  const srcStat = await statFn(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n\n  if (\n    srcStat.isFile() ||\n    srcStat.isCharacterDevice() ||\n    srcStat.isBlockDevice()\n  ) return onFile(srcStat, destStat, src, dest, opts)\n\n  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nasync function onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n\n  if (opts.overwrite) {\n    await fs.unlink(dest)\n    return copyFile(srcStat, src, dest, opts)\n  }\n  if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nasync function copyFile (srcStat, src, dest, opts) {\n  await fs.copyFile(src, dest)\n  if (opts.preserveTimestamps) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcStat.mode)) {\n      await makeFileWritable(dest, srcStat.mode)\n    }\n\n    // Set timestamps and mode correspondingly\n\n    // Note that The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n    const updatedSrcStat = await fs.stat(src)\n    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n  }\n\n  return fs.chmod(dest, srcStat.mode)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return fs.chmod(dest, srcMode | 0o200)\n}\n\nasync function onDir (srcStat, destStat, src, dest, opts) {\n  // the dest directory might not exist, create it\n  if (!destStat) {\n    await fs.mkdir(dest)\n  }\n\n  const items = await fs.readdir(src)\n\n  // loop through the files in the current directory to copy everything\n  await Promise.all(items.map(async item => {\n    const srcItem = path.join(src, item)\n    const destItem = path.join(dest, item)\n\n    // skip the item if it is matches by the filter function\n    const include = await runFilter(srcItem, destItem, opts)\n    if (!include) return\n\n    const { destStat } = await stat.checkPaths(srcItem, destItem, 'copy', opts)\n\n    // If the item is a copyable file, `getStatsAndPerformCopy` will copy it\n    // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively\n    return getStatsAndPerformCopy(destStat, srcItem, destItem, opts)\n  }))\n\n  if (!destStat) {\n    await fs.chmod(dest, srcStat.mode)\n  }\n}\n\nasync function onLink (destStat, src, dest, opts) {\n  let resolvedSrc = await fs.readlink(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n  if (!destStat) {\n    return fs.symlink(resolvedSrc, dest)\n  }\n\n  let resolvedDest = null\n  try {\n    resolvedDest = await fs.readlink(dest)\n  } catch (e) {\n    // dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest)\n    throw e\n  }\n  if (opts.dereference) {\n    resolvedDest = path.resolve(process.cwd(), resolvedDest)\n  }\n  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n  }\n\n  // do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n  }\n\n  // copy the link\n  await fs.unlink(dest)\n  return fs.symlink(resolvedSrc, dest)\n}\n\nmodule.exports = copy\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}