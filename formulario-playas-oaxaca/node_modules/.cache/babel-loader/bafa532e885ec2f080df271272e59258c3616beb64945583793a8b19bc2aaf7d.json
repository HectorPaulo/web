{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\nconst path = require('path');\nconst mkdirsSync = require('../mkdirs').mkdirsSync;\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync;\nconst stat = require('../util/stat');\nfunction copySync(src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n  opts = opts || {};\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' + '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0002');\n  }\n  const {\n    srcStat,\n    destStat\n  } = stat.checkPathsSync(src, dest, 'copy', opts);\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy');\n  return handleFilterAndCopy(destStat, src, dest, opts);\n}\nfunction handleFilterAndCopy(destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return;\n  const destParent = path.dirname(dest);\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent);\n  return getStats(destStat, src, dest, opts);\n}\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return;\n  return getStats(destStat, src, dest, opts);\n}\nfunction getStats(destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;\n  const srcStat = statSync(src);\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);\n  throw new Error(`Unknown file: ${src}`);\n}\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts);\n  return mayCopyFile(srcStat, src, dest, opts);\n}\nfunction mayCopyFile(srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest);\n    return copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`);\n  }\n}\nfunction copyFile(srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest);\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);\n  return setDestMode(dest, srcStat.mode);\n}\nfunction handleTimestamps(srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);\n  return setDestTimestamps(src, dest);\n}\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\nfunction makeFileWritable(dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200);\n}\nfunction setDestMode(dest, srcMode) {\n  return fs.chmodSync(dest, srcMode);\n}\nfunction setDestTimestamps(src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src);\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n}\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  return copyDir(src, dest, opts);\n}\nfunction mkDirAndCopy(srcMode, src, dest, opts) {\n  fs.mkdirSync(dest);\n  copyDir(src, dest, opts);\n  return setDestMode(dest, srcMode);\n}\nfunction copyDir(src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));\n}\nfunction copyDirItem(item, src, dest, opts) {\n  const srcItem = path.join(src, item);\n  const destItem = path.join(dest, item);\n  const {\n    destStat\n  } = stat.checkPathsSync(srcItem, destItem, 'copy', opts);\n  return startCopy(destStat, srcItem, destItem, opts);\n}\nfunction onLink(destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src);\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n  }\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest);\n  } else {\n    let resolvedDest;\n    try {\n      resolvedDest = fs.readlinkSync(dest);\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest);\n      throw err;\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest);\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);\n    }\n    return copyLink(resolvedSrc, dest);\n  }\n}\nfunction copyLink(resolvedSrc, dest) {\n  fs.unlinkSync(dest);\n  return fs.symlinkSync(resolvedSrc, dest);\n}\nmodule.exports = copySync;","map":{"version":3,"names":["fs","require","path","mkdirsSync","utimesMillisSync","stat","copySync","src","dest","opts","filter","clobber","overwrite","preserveTimestamps","process","arch","emitWarning","srcStat","destStat","checkPathsSync","checkParentPathsSync","handleFilterAndCopy","destParent","dirname","existsSync","getStats","startCopy","statSync","dereference","lstatSync","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","isSocket","Error","isFIFO","copyFile","mayCopyFile","unlinkSync","errorOnExist","copyFileSync","handleTimestamps","mode","setDestMode","srcMode","fileIsNotWritable","makeFileWritable","setDestTimestamps","chmodSync","updatedSrcStat","atime","mtime","mkDirAndCopy","copyDir","mkdirSync","readdirSync","forEach","item","copyDirItem","srcItem","join","destItem","resolvedSrc","readlinkSync","resolve","cwd","symlinkSync","resolvedDest","err","code","isSrcSubdir","copyLink","module","exports"],"sources":["/home/paulo/.Code/web/login-estructura/login-no-funcional/node_modules/fs-extra/lib/copy/copy-sync.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0002'\n    )\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}